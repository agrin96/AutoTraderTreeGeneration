from __future__ import annotations
from typing import List,Dict,Tuple
import pandas as pd
import numpy as np

from DataStructures.Node import Node
from DataStructures.Terminal import Terminal
from TreeActions import tree_depth
import zlib


def make_pop_decisions(pop:Dict,data:pd.DataFrame,decision_memo:Dict)->Tuple:
	"""Run a pop through the decision making process"""
	tree = pop["tree"]
	update_decisions(tree,data,decision_memo)
	
	return list(make_decision(tree)),decision_memo


def update_decisions(node:Node,data:pd.DataFrame,decision_memo:Dict):
	"""Generates the decisions for each indicator in each variable. This step
	stores the updated set of decisions in each contained node.
	Returns the updated memo_dictionary"""
	if isinstance(node,Terminal):
		return
	
	indicator = node.get_variable()
	memo_value = zlib.adler32(F"{node}{len(data.index)}".encode('utf-8'))

	if memo_value in decision_memo:
		indicator["decisions"] = decision_memo[memo_value]	
	else:
		decision_generator = indicator["generator"]
		variables = {k:v["value"] for k,v in indicator["variables"].items()}
		indicator["decisions"] = decision_generator(data,**variables)

		indicator["memo"] = indicator["decisions"]
		decision_memo[memo_value] = indicator["decisions"]

	node.set_variable(indicator)

	for child in node.children():
		update_decisions(child,data,decision_memo)


def score_decisions(
		funds:float,
		fee:float,
		decisions:List[str],
		close:np.array)->Tuple:
	"""Score the decisions made by running them through the prices and 
	executing the trades fake.
	Parameters:
		funds (float): The starting funds given to the bot.
		fee (float): The trading fee expressed as a decimal.
		decisions (List[str]): The decisions taken by the bot
	Returns the final funds generated by the bot to be used as a fitness 
	value."""
	current_balance = funds
	bought_balance = 0.0

	coin_balance = 0.0
	gain_trades = 0
	lose_trades = 0
	invalid_trades = 0

	idx = 0
	prev = "SELL"
	while idx < close.shape[0]:
		if decisions[idx] == "HOLD":
			idx += 1
			continue

		if prev == "SELL" and decisions[idx] == "BUY":
			coin_balance = (current_balance/close[idx])*(1-fee)
			bought_balance = current_balance
			# The current balance here is represented as the potential profit of
			# selling it right after buying it.
			# current_balance = coin_balance*close[idx]*(1-fee)
			current_balance = 0.0
			prev = "BUY"
			idx += 1
			continue

		if prev == "BUY" and decisions[idx] == "SELL":
			current_balance = coin_balance*close[idx]*(1-fee)
			if current_balance > bought_balance:
				gain_trades += 1
			else:
				lose_trades += 1
			prev = "SELL"
			idx += 1
			continue
		
		invalid_trades += 1
		# If we do a double buy or double sell nothing will happen since we
		# wouldnt have the funds in either case.
		idx += 1
	return current_balance,gain_trades,lose_trades,invalid_trades


def calculate_fitness(pop:Dict,
					  max_depth:int,
					  initial_balance:float,
					  long_balance:float)->Dict:
	"""Computes a fitness value for the tree based on the profit, depth and
	valid trades executed. This allows us to pressure the trees not to get 
	larger than the maximum depth and make sure we penalize trees doing nothing.
	We also penalize 0 profit by setting it to negative initial balance.
		
	Note that the degree of the modifier modulates the penalty on the fitness.
	Parameters:
		max_depth (int): The maximum tree depth allowed for trees of this type
		initial_balance (float): The starting balance of the tree.
	Returns the pop with fitness adjusted."""
	profit = (pop["balance"] - initial_balance)
	if profit == 0:
		profit = -initial_balance
	
	pop_depth = tree_depth(pop["tree"])
	# depth_modifier = np.power(min(max_depth/pop_depth,1),3)
	depth_modifier = 1.0

	long_position_modifier = (pop["balance"]/long_balance)

	trade_modifier = 1.0
	if pop["gtrades"] > 0:
			trade_modifier = trade_modifier * pop["gtrades"]

	if profit < 0:
		# Makes a negative result more negative.
		pop["fitness"] = profit*(1/depth_modifier)*trade_modifier
	else:
		pop["fitness"] = profit*depth_modifier*long_position_modifier*trade_modifier
	
	return pop


def make_decision(node:Node)->np.array:
	"""Evalautes the resulting decisions in each node. Follows the branches
	and returns the end decisions as an array of terminals"""
	decisions = node.get_decisions()
	for child,d in zip(node.children(),["BUY","HOLD","SELL"]):
		if not isinstance(child,Terminal):
			child_decisions = make_decision(child)
			decisions = np.where(decisions==d,child_decisions,decisions)
	
	return decisions


def natural_price_increase(config:Dict,data:pd.DataFrame)->float:
	"""Calculates the natural growth of a long position in this dataframe.
	This serves as a baseline for seeing whether we are outperforming the mean
	growth.
	Returns the balance of a long position."""
	initial_funds = config["evaluation"]["initial_funds"]
	fee = config["evaluation"]["trading_fee_percent"]

	starting_price = data["close"].values[0]
	ending_price = data["close"].values[-1]

	coins = (initial_funds/starting_price)*(1-fee)
	final_balance = (coins*ending_price)*(1-fee)

	return final_balance
	