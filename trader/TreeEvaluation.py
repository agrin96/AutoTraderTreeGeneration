from __future__ import annotations
from typing import List,Dict,Tuple
import pandas as pd
import numpy as np

from DataStructures.Node import Node
from DataStructures.Terminal import Terminal
from TreeActions import tree_depth
import zlib


def make_pop_decisions(pop:Dict,data:pd.DataFrame,decision_memo:Dict)->Tuple:
	"""Run a pop through the decision making process"""
	tree = pop["tree"]
	update_decisions(tree,data,decision_memo)
	
	return list(make_decision(tree)),decision_memo


def update_decisions(node:Node,data:pd.DataFrame,decision_memo:Dict):
	"""Generates the decisions for each indicator in each variable. This step
	stores the updated set of decisions in each contained node.
	Returns the updated memo_dictionary"""
	if isinstance(node,Terminal):
		return
	
	indicator = node.get_variable()
	if indicator["memo"] in decision_memo:
		indicator["decisions"] = decision_memo["memo"]	
	else:
		decision_generator = indicator["generator"]
		variables = {k:v["value"] for k,v in indicator["variables"].items()}
		indicator["decisions"] = decision_generator(data,**variables)
		
		memo_value = zlib.adler32(str(node).encode('utf-8'))
		indicator[memo_value] = indicator["decisions"]
		decision_memo[memo_value] = indicator["decisions"]

	node.set_variable(indicator)

	for child in node.children():
		update_decisions(child,data,decision_memo)


def score_decisions(
		funds:float,
		fee:float,
		decisions:List[str],
		close:np.array)->Tuple:
	"""Score the decisions made by running them through the prices and 
	executing the trades fake.
	Parameters:
		funds (float): The starting funds given to the bot.
		fee (float): The trading fee expressed as a decimal.
		decisions (List[str]): The decisions taken by the bot
		best_bid (np.array): history of best bids.
		best_ask (np.array)" history of best asks.
	Returns the final funds generated by the bot to be used as a fitness 
	value."""
	current_balance = funds

	coin_balance = 0.0
	valid_trades = 0

	idx = 0
	prev = "SELL"
	while idx < close.shape[0]:
		if decisions[idx] == "HOLD":
			idx += 1
			continue

		if prev == "SELL" and decisions[idx] == "BUY":
			coin_balance = (current_balance/close[idx])*(1-fee)
			# The current balance here is represented as the potential profit of
			# selling it right after buying it.
			prev = "BUY"
			idx += 1
			continue

		if prev == "BUY" and decisions[idx] == "SELL":
			current_balance = coin_balance*close[idx]*(1-fee)
			prev = "SELL"
			idx += 1
			valid_trades += 1
			continue
		
		# If we do a double buy or double sell nothing will happen since we
		# wouldnt have the funds in either case.
		idx += 1
	return current_balance,valid_trades


def calculate_fitness(pop:Dict,
					  max_depth:int,
					  initial_balance:float,
					  long_balance:float)->Dict:
	"""Computes a fitness value for the tree based on the profit, depth and
	valid trades executed. This allows us to pressure the trees not to get 
	larger than the maximum depth and make sure we penalize trees doing nothing.
	We also penalize 0 profit by setting it to negative initial balance.
		
	Note that the degree of the modifier modulates the penalty on the fitness.
	Parameters:
		max_depth (int): The maximum tree depth allowed for trees of this type
		initial_balance (float): The starting balance of the tree.
	Returns the pop with fitness adjusted."""
	profit = (pop["balance"] - initial_balance)
	if profit == 0:
		profit = -initial_balance
	
	pop_depth = tree_depth(pop["tree"])
	depth_modifier = np.power(min(max_depth/pop_depth,1),3)

	long_position_modifier = (pop["balance"]/long_balance)

	if pop["trades"] > 1:
		if profit > 0:
			profit = profit*2*np.log(pop["trades"])
		else:
			# We reward the pop for making more trades even if not so good.
			profit = profit*(1/(2*np.log(pop["trades"])))

	if profit < 0:
		# Makes a negative result more negative.
		pop["fitness"] = profit*(1/depth_modifier)
	else:
		pop["fitness"] = profit*depth_modifier*long_position_modifier
	
	return pop


def number_of_valid_trades(decisions:List[str])->int:
	"""Find the number of valid buy-sell pairs in the decision set. This is
	a measure of the number of valid trades commited by this bot."""
	valid_trades = 0
	prev_decision = "SELL"
	for decision in decisions:
		if decision == "BUY" and prev_decision == "SELL":
			prev_decision = "BUY"
		elif decision == "SELL" and prev_decision == "BUY":
			prev_decision = "SELL"
			valid_trades += 1

	return valid_trades


def make_decision(node:Node)->np.array:
	"""Evalautes the resulting decisions in each node. Follows the branches
	and returns the end decisions as an array of terminals"""
	decisions = node.get_decisions()
	for child,d in zip(node.children(),["BUY","HOLD","SELL"]):
		if not isinstance(child,Terminal):
			child_decisions = make_decision(child)
			decisions = np.where(decisions==d,child_decisions,decisions)
	
	return decisions


def natural_price_increase(config:Dict,data:pd.DataFrame)->float:
	"""Calculates the natural growth of a long position in this dataframe.
	This serves as a baseline for seeing whether we are outperforming the mean
	growth.
	Returns the balance of a long position."""
	initial_funds = config["evaluation"]["initial_funds"]
	fee = config["evaluation"]["trading_fee_percent"]

	starting_price = data["close"].values[0]
	ending_price = data["close"].values[-1]

	coins = (initial_funds/starting_price)*(1-fee)
	final_balance = (coins*ending_price)*(1-fee)

	return final_balance
	