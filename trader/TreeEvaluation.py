from __future__ import annotations
from typing import List,Dict,Tuple
import pandas as pd
import numpy as np

from DataStructures.Node import Node
from DataStructures.Terminal import Terminal
from TreeActions import tree_depth
import zlib


def make_pop_decisions(pop:Dict,data:pd.DataFrame,decision_memo:Dict)->Tuple:
	"""Run a pop through the decision making process"""
	tree = pop["tree"]
	update_decisions(tree,data,decision_memo)
	
	return list(make_decision(tree)),decision_memo


def update_decisions(node:Node,data:pd.DataFrame,decision_memo:Dict):
	"""Generates the decisions for each indicator in each variable. This step
	stores the updated set of decisions in each contained node.
	Returns the updated memo_dictionary"""
	if isinstance(node,Terminal):
		return
	
	indicator = node.get_variable()
	memo_value = zlib.adler32(F"{node}{len(data.index)}".encode('utf-8'))

	if memo_value in decision_memo:
		indicator["decisions"] = decision_memo[memo_value]	
	else:
		decision_generator = indicator["generator"]
		variables = {k:v["value"] for k,v in indicator["variables"].items()}
		indicator["decisions"] = decision_generator(data,**variables)

		indicator["memo"] = indicator["decisions"]
		decision_memo[memo_value] = indicator["decisions"]

	node.set_variable(indicator)

	for child in node.children():
		update_decisions(child,data,decision_memo)


def score_decisions(
		funds:float,
		fee:float,
		decisions:List[str],
		data:pd.DataFrame,
		prices:pd.DataFrame,
		candle_period:int)->Tuple:
	"""Score the decisions made by running them through the prices and 
	executing the trades fake.
	Parameters:
		funds (float): The starting funds given to the bot.
		fee (float): The trading fee expressed as a decimal.
		decisions (List[str]): The decisions taken by the bot
		best_bid (np.array): history of best bids.
		best_ask (np.array)" history of best asks.
	Returns the final funds generated by the bot to be used as a fitness 
	value."""
	current_balance = funds
	gain_trades = 0
	lose_trades = 0
	
	coin_balance = 0.0
	bought_balance = 0.0
	
	# Take profit at 0.5% gain
	take_profit = 1.005
	# Stop loss when 3% loss
	stop_loss = 0.97
	# hours -> seconds tells us how many indexes to wait
	stop_time = int(0.25 * 3600)

	mask = np.where(np.array(decisions)=="BUY",True,False)
	buy_indices = data.loc[mask,"index"]

	current_idx = 0
	for buy_idx in buy_indices:
		if current_idx >= buy_idx:
			continue

		current_idx = buy_idx
		bought_balance = current_balance
		coin_balance = (current_balance/prices.loc[current_idx,"best_ask"])*(1-fee)
		# print("bought at: ",bought_balance)

		period_prices = prices.iloc[current_idx:current_idx+stop_time]["best_bid"].values
		estimations = coin_balance*period_prices*(1-fee)

		take = np.where(estimations>=(take_profit*bought_balance))[0]
		stop = np.where(estimations<=(stop_loss*bought_balance))[0]
		
		take_idx = stop_time if len(take) == 0 else take[0]
		stop_idx = stop_time if len(stop) == 0 else stop[0]

		if take_idx < stop_idx:
			current_balance = estimations[take_idx]
			# print("sold gain at: ",estimations[take_idx])
			# print(estimations)
			current_idx += take_idx
			coin_balance = 0.0
			gain_trades += 1
		elif stop_idx < take_idx:
			current_balance = estimations[stop_idx]
			# print("sold loss at: ",estimations[stop_idx-2:stop_idx+2])
			current_idx += stop_idx
			coin_balance = 0.0
			lose_trades += 1
		else:
			current_balance = estimations[-1]
			# print("sold default at: ",estimations[-1])
			current_idx += stop_time
			coin_balance = 0.0
			lose_trades += 1

	return current_balance,gain_trades,lose_trades


def calculate_fitness(pop:Dict,
					  max_depth:int,
					  initial_balance:float,
					  long_balance:float)->Dict:
	"""Computes a fitness value for the tree based on the profit, depth and
	valid trades executed. This allows us to pressure the trees not to get 
	larger than the maximum depth and make sure we penalize trees doing nothing.
	We also penalize 0 profit by setting it to negative initial balance.
		
	Note that the degree of the modifier modulates the penalty on the fitness.
	Parameters:
		max_depth (int): The maximum tree depth allowed for trees of this type
		initial_balance (float): The starting balance of the tree.
	Returns the pop with fitness adjusted."""
	profit = (pop["balance"] - initial_balance)
	if profit == 0:
		profit = -initial_balance
	
	pop_depth = tree_depth(pop["tree"])
	depth_modifier = np.power(min(max_depth/pop_depth,1),3)

	long_position_modifier = (pop["balance"]/long_balance)

	# trades_modifier = pop["gtrades"] if pop["gtrades"] > 0 else 1
	# if pop["ltrades"] > 0:
	# 	trades_modifier = trades_modifier / pop["ltrades"]

	# if profit > 0:
	# 	profit = profit*trades_modifier
	# else:
	# 	# We reward the pop for making more trades even if not so good.
	# 	profit = profit*(1/trades_modifier)

	if profit < 0:
		# Makes a negative result more negative.
		pop["fitness"] = profit*(1/depth_modifier)
	else:
		pop["fitness"] = profit*depth_modifier*long_position_modifier
	
	return pop


def number_of_valid_trades(decisions:List[str])->int:
	"""Find the number of valid buy-sell pairs in the decision set. This is
	a measure of the number of valid trades commited by this bot."""
	valid_trades = 0
	prev_decision = "SELL"
	for decision in decisions:
		if decision == "BUY" and prev_decision == "SELL":
			prev_decision = "BUY"
		elif decision == "SELL" and prev_decision == "BUY":
			prev_decision = "SELL"
			valid_trades += 1

	return valid_trades


def make_decision(node:Node)->np.array:
	"""Evalautes the resulting decisions in each node. Follows the branches
	and returns the end decisions as an array of terminals"""
	decisions = node.get_decisions()
	for child,d in zip(node.children(),["BUY","HOLD","SELL"]):
		if not isinstance(child,Terminal):
			child_decisions = make_decision(child)
			decisions = np.where(decisions==d,child_decisions,decisions)
	
	return decisions


def natural_price_increase(config:Dict,data:pd.DataFrame)->float:
	"""Calculates the natural growth of a long position in this dataframe.
	This serves as a baseline for seeing whether we are outperforming the mean
	growth.
	Returns the balance of a long position."""
	initial_funds = config["evaluation"]["initial_funds"]
	fee = config["evaluation"]["trading_fee_percent"]

	starting_price = data["close"].values[0]
	ending_price = data["close"].values[-1]

	coins = (initial_funds/starting_price)*(1-fee)
	final_balance = (coins*ending_price)*(1-fee)

	return final_balance
	