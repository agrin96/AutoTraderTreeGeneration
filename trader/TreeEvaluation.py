from __future__ import annotations
from typing import List,Union,Dict
import pandas as pd
import numpy as np

from Common import random_choice
from DataStructures.Node import Node
from DataStructures.Terminal import Terminal
from TreeActions import tree_depth,get_node,replace_node,set_node_threshold


def make_pop_decisions(pop:Dict,data:pd.DataFrame)->List[str]:
    """Runs a single `pop` through the decision making process. This means
    iteratively passing in data points as substitution values for the trees.
    This allows us to modify the bought threshold in the sell tree during
    this evaluation.
    Returns a list of decisions from the buy and sell trees."""
    subs = data.to_dict(orient="records")
    decisions = []
    bought_price = 20000
    for sub in subs:
        sub["bought_price"] = bought_price
        if pop["state"] == "BUY":
            decision = make_decision(pop["buy"],sub)
            if decision == "BUY":
                set_node_threshold(pop["sell"],"bought_price",sub["best_ask"])
                bought_price = sub["best_ask"]
                pop["state"] = "SELL"
        else:
            decision = make_decision(pop["sell"],sub)
            if decision == "SELL":
                pop["state"] = "BUY"
        decisions.append(decision)
    return decisions


def score_decisions(
        funds:float,
        fee:float,
        decisions:List[str],
        best_bid:np.array,
        best_ask:np.array)->float:
    """Score the decisions made by running them through the prices and 
    executing the trades fake.
    Parameters:
        funds (float): The starting funds given to the bot.
        fee (float): The trading fee expressed as a decimal.
        decisions (List[str]): The decisions taken by the bot
        best_bid (np.array): history of best bids.
        best_ask (np.array)" history of best asks.
    Returns the final funds generated by the bot to be used as a fitness 
    value."""
    current_balance = funds
    current_coin = 0

    idx = 0
    prev = "SELL"
    while idx < best_ask.shape[0]:
        if decisions[idx] == "HOLD":
            idx += 1
            continue

        if prev == "SELL" and decisions[idx] == "BUY":
            current_coin = (current_balance/best_ask[idx])*(1-fee)
            # The current balance here is represented as the potential profit of
            # selling it right after buying it.
            current_balance = current_coin*best_bid[idx]*(1-fee)
            prev = "BUY"
            idx += 1
            continue

        if prev == "BUY" and decisions[idx] == "SELL":
            current_balance = current_coin*best_bid[idx]*(1-fee)
            current_coin = 0
            prev = "SELL"
            idx += 1
            continue
        # If we do a double buy or double sell nothing will happen since we
        # wouldnt have the funds in either case.
        idx += 1

    return current_balance


def make_decision(node:Node,substitutions:Dict)->str:
    """Evaluates a single instance of substitution data on the tree specified.
    Returns the single decision result of the evaluation."""
    if isinstance(node,Terminal):
        return str(node)
    
    # returns either the left or right child
    next_node = node.evaluate(substitutions)
    return make_decision(next_node,substitutions)


def step_thresholds(tree:Node,generation:int,step_percent:float):
    """Changes the tree thresholds based on the step_percent anealed by the
    generation count.
    Parameters:
        tree (Node): The root node of the tree we are adjusting
        generation (int): The current generation we are at to use to simulate 
            our annealing steps.
        step_percent (float): The initial base step used expressed as a decimal
            percent"""
    if isinstance(tree,Node):
        tree.step_threshold(base_step=step_percent,generation=generation)
        first,second = tree.children()

        step_thresholds(first,generation,step_percent)
        step_thresholds(second,generation,step_percent)
