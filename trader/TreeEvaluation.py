from __future__ import annotations
from typing import List,Union,Dict,Tuple
import pandas as pd
import numpy as np

from Common import random_choice
from DataStructures.Node import Node
from DataStructures.Terminal import Terminal
from TreeActions import tree_depth,get_node,replace_node,set_node_threshold,pprint_tree


def make_pop_decisions(buy_tree:Dict,sell_tree:Dict,data:pd.DataFrame)->List[str]:
    """Runs a single `pop` through the decision making process. This means
    iteratively passing in data points as substitution values for the trees.
    This allows us to modify the bought threshold in the sell tree during
    this evaluation.
    Returns a list of decisions from the buy and sell trees."""
    if buy_tree["popid"] != sell_tree["popid"]:
        raise RuntimeError(
        "When evaluating buy sell trees, their popids were found to be"\
        F" different. \n{buy_tree}\n{sell_tree}")

    subs = data.to_dict(orient="records")
    bought_price = 20000
    decisions = []
    
    state = "BUY"
    for sub in subs:
        sub["bought_price"] = bought_price
        if state == "BUY":
            decision = make_decision(buy_tree["tree"],sub)
            if decision == "BUY":
                set_node_threshold(node=sell_tree["tree"],
                                   variable="bought_price",
                                   new_threshold=sub["best_ask"])
                bought_price = sub["best_ask"]
                state = "SELL"
        else:
            decision = make_decision(sell_tree["tree"],sub)
            if decision == "SELL":
                state = "BUY"
        decisions.append(decision)
    return decisions


def score_decisions(
        funds:float,
        fee:float,
        decisions:List[str],
        best_bid:np.array,
        best_ask:np.array)->Tuple:
    """Score the decisions made by running them through the prices and 
    executing the trades fake.
    Parameters:
        funds (float): The starting funds given to the bot.
        fee (float): The trading fee expressed as a decimal.
        decisions (List[str]): The decisions taken by the bot
        best_bid (np.array): history of best bids.
        best_ask (np.array)" history of best asks.
    Returns the final funds generated by the bot to be used as a fitness 
    value."""
    current_balance = funds

    coin_balance = 0.0
    valid_trades = 0

    idx = 0
    prev = "SELL"
    while idx < best_ask.shape[0]:
        if decisions[idx] == "HOLD":
            idx += 1
            continue

        if prev == "SELL" and decisions[idx] == "BUY":
            coin_balance = (current_balance/best_ask[idx])*(1-fee)
            # The current balance here is represented as the potential profit of
            # selling it right after buying it.
            prev = "BUY"
            idx += 1
            continue

        if prev == "BUY" and decisions[idx] == "SELL":
            current_balance = coin_balance*best_bid[idx]*(1-fee)
            prev = "SELL"
            idx += 1
            valid_trades += 1
            continue
        
        # If we do a double buy or double sell nothing will happen since we
        # wouldnt have the funds in either case.
        idx += 1
    return current_balance,valid_trades


def calculate_fitness(pop:Dict,
                      max_depth:int,
                      initial_balance:float)->Dict:
    """Computes a fitness value for the tree based on the profit, depth and
    valid trades executed. This allows us to pressure the trees not to get 
    larger than the maximum depth and make sure we penalize trees doing nothing.
    We also penalize 0 profit by setting it to negative initial balance.
        
    Note that the degree of the modifier modulates the penalty on the fitness.
    Parameters:
        max_depth (int): The maximum tree depth allowed for trees of this type
        initial_balance (float): The starting balance of the tree.
    Returns the pop with fitness adjusted."""
    profit = (pop["balance"] - initial_balance)
    if profit == 0:
        profit = -initial_balance
    
    pop_depth = tree_depth(pop["tree"])
    depth_modifier = np.power(min(max_depth/pop_depth,1),3)

    if pop["trades"] > 1:
        if profit > 0:
            profit = profit*2*np.log(pop["trades"])
        else:
            # We reward the pop for making more trades even if not so good.
            profit = profit*(1/(2*np.log(pop["trades"])))

    if profit < 0:
        # Makes a negative result more negative.
        pop["fitness"] = profit*(1/depth_modifier)
    else:
        pop["fitness"] = profit*depth_modifier
    
    return pop


def number_of_valid_trades(decisions:List[str])->int:
    """Find the number of valid buy-sell pairs in the decision set. This is
    a measure of the number of valid trades commited by this bot."""
    valid_trades = 0
    prev_decision = "SELL"
    for decision in decisions:
        if decision == "BUY" and prev_decision == "SELL":
            prev_decision = "BUY"
        elif decision == "SELL" and prev_decision == "BUY":
            prev_decision = "SELL"
            valid_trades += 1

    return valid_trades


def make_decision(node:Node,substitutions:Dict)->str:
    """Evaluates a single instance of substitution data on the tree specified.
    Returns the single decision result of the evaluation."""
    if isinstance(node,Terminal):
        return str(node)
    
    # returns either the left or right child
    next_node = node.evaluate(substitutions)
    return make_decision(next_node,substitutions)


def step_thresholds(tree:Node,generation:int,step_percent:float):
    """Changes the tree thresholds based on the step_percent anealed by the
    generation count.
    Parameters:
        tree (Node): The root node of the tree we are adjusting
        generation (int): The current generation we are at to use to simulate 
            our annealing steps.
        step_percent (float): The initial base step used expressed as a decimal
            percent"""
    if isinstance(tree,Node):
        tree.step_threshold(base_step=step_percent,generation=generation)
        first,second = tree.children()

        step_thresholds(first,generation,step_percent)
        step_thresholds(second,generation,step_percent)
